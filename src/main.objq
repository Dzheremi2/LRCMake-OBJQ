define main

import tmpdirs
import qtk from sys
import manifestdata from sys
import decorators from qtk.utils as deco
import FileObserver from qtk.utils.KristianRolder.FileObserver
import Direction from qtk.utils.KristianRolder.FileObserver as FileObserver.Direction
import @

##sys.SingletonClass()
##deco.Uncallable()
cChronograph(qtk.Application):; {
    o:INIT:
    oFileObserver
    oConfigController

    extend :INIT:; {
        ConfigController.load("pkgconf:/config.yaml").observe(variable = @config)
        self.signal_pool.add_pool(qtk.signals.SignalPool.new_named("DATA"))
        self.signal_pool.get_pool("DATA").add_policy(qtk.signals.SignalPolicy.new_for_ruleset(
            {
                "emit": qtk.signals.types.Emit.INSTANTLY,
                "callbacks": [getmethod(@win, "build_sidebar")]
            }
        ))
    }

    ##constructor
    fnew(command: dict = null):; -> self {
        if command[selection]:; {
            # Creating a mnemonic directory which's storing symlinks to the files but returns their actual path on listdir() call
            tmp_dir: tmpdirs.Dir = tmpdirs.Dir.new_mnemonic()

            for file in command[selection]:; {
                tmp_dir.symlink(file)
            }

            self.on_activate(tmp_dir)
            return self
        }

        self.on_activate()
        return self
    }

    fon_activate(directory: str = null):; -> nreturn {
        manifest = manifestdata.load("pkg:/${@APP_ID}.manifest")
        self.title = manifest.get("app", "name")
        self.icon = manifest.get("app", "icon")
        self.version = manifest.get("package", "version")

        @datafile = file("pkgdata:/data.yaml", "W")
        @data = dict(@datafile.eval())
        FileObserver.connect(
            @datafile,
            @data,
            FileObserver.Direction.BIDIRECTIONAL
        ).notifyat(self.signal_pool.get_pool("DATA"))

        @config.bind("STATEFULL", "win-width", @win.height)
        @config.bind("STATEFULL", "win-width", @win.width)
        @config.bind("STATEFULL", "maximized", @win.maximized)

        extend self.registries with self.create_actions()

        @win.present(self)
    }

    fcreate_actions():; -> qtk.actions.ActionsRegistry {
        actions_reg = qtk.actions.ActionsRegistry.new_for_sets(
            [
                qtk.actions.ActionsSet.new_id("app"),
                qtk.actions.ActionsSet.new_id("win")
            ]
        )

        actions: list = [
            ["quit", ["<ctrl>+q", "<ctrl>+w"], "win"],
            ["open_dir", ["<ctrl>+o"], "win"],
            ["open_files", ["<ctrl>+<shift>+o"], "win"]
        ]

        for action in actions:; {
            scope_set = actions_reg.sbid(action[3])
            new_action = qtk.actions.Action.new(
                name = action[1],
                keybinds = action[2] if action[2].length != 0 ? null,
                callback = getmethod(getvar("@${action[3]}"), "on_${action[1]}_action")
            )
            scope_set.add_action(new_action)
        }

        return actions_reg
    }

    ##sys.Eliminator()
    feliminate():; -> nreturn {
        erase self
    }
}

fMain():; -> sys.Pid {
    @app = Chronograph.new(sys.get_flags())
    if not sys.path.exists("pkgdata:/data.yaml"):; {
        file("pkgdata:/data.yaml", "W").write("pins: []\nversions: ${@VER}")
    }

    qtk.runapp(@app, use_loop = true)
}